/* -*- mode: C++; indent-tabs-mode: nil; -*- */
/** \file
 * \brief YARP port classes for the C++ node interface.
 *
 * Implement the communication interface with YARP port for a C++ node.
 *
 * This file is part of the openBuildNet simulation framework
 * (OBN-Sim) developed at EPFL.
 *
 * \author Truong X. Nghiem (xuan.nghiem@epfl.ch)
 */

#ifndef OBNNODE_YARPPORT_H_
#define OBNNODE_YARPPORT_H_

#include <type_traits>
#include <string>
#include <queue>        // std::queue

#include <yarp/os/all.h>
#include <sharedqueue_yarp.h>

#include <Eigen/Core>
#include <obnsim_io.pb.h>

#include <obnnode_yarpportbase.h>
#include <obnnode_yarpnode.h>

namespace OBNnode {
    
    /** \brief Template class for an Yarp input port with specific type.
     
     This template class defines an Yarp input port with a specific fixed type (e.g. scalar, vector, matrix).
     Specializations are used to define the classes for each type.
     The template has the following signature:
        template <FORMAT, DATATYPE, STRICT> class YarpInput;
     where:
     - FORMAT specifies the message format and is one of: OBN_PB for ProtoBuf for a fixed type, OBN_PB_USER for any ProtoBuf message format (which will be specified by DATATYPE), or OBN_BIN for raw binary data (user-defined format).
     - DATATYPE specifies the type of data, depending on FORMAT
        + If FORMAT is OBN_PB, DATATYPE can be:
            . bool, int32_t, int64_t, uint32_t, uint64_t, double, float: for scalars.
            . obn_vector<t> where t is one of the above types: a variable-length vector of elements of such type.
            . obn_vector_fixed<t, N> where t is one of the above type and N is a constant positive integer: a fixed-length vector of elements of such type. The data is statically allocated, hence more efficient. Incoming data will be checked and an error will be raised if its length is different than N.
            . obn_matrix<t> similar to obn_vector<t> but for a 2-D matrix.
            . obn_matrix_fixed<t, M, N> similar to obn_vector_fixed<t, N> but for a matrix of fixed numbers of rows (M) and columns (N).
        + If FORMAT is OBN_PB_USER then DATATYPE must be a ProtoBuf class generated by protoc. This may not be checked at compile time, but certain necessary methods of a ProtoBuf class for encoding and decoding data must be present. The data read from this port will be an object of this ProtoBuf class. The user is responsible for extracting values from the object.
        + If FORMAT is OBN_BIN then DATATYPE is irrelevant because the data read from this input port will be a binary string.
     - STRICT is a boolean value: if it is false (default), the input port is nonstrict, which means that any new incoming data will immediately replace the current datum (even if it has not been accessed); if it is true, the input port is strict, i.e. new incoming messages will not replace past messages but be queued to be accessed later.
     */
    template <typename F, typename D, const bool S=false>
    class YarpInput;
    
    
    /** \brief Template class for an Yarp output port with specific type.
     
     This template class defines an Yarp output port with a specific fixed type (e.g. scalar, vector, matrix).
     Specializations are used to define the classes for each type.
     The template has the following signature:
     template <FORMAT, DATATYPE> class YarpOutput;
     where:
     - FORMAT specifies the message format and is one of: OBN_PB for ProtoBuf for a fixed type, OBN_PB_USER for any ProtoBuf message format (which will be specified by DATATYPE), or OBN_BIN for raw binary data (user-defined format).
     - DATATYPE specifies the type of data, depending on FORMAT
        + If FORMAT is OBN_PB, DATATYPE can be:
            . bool, int32_t, int64_t, uint32_t, uint64_t, double, float: for scalars.
            . obn_vector<t> where t is one of the above types: a variable-length vector of elements of such type.
            . obn_vector_fixed<t, N> where t is one of the above type and N is a constant positive integer: a fixed-length vector of elements of such type. The data is statically allocated, hence more efficient.
            . obn_matrix<t> similar to obn_vector<t> but for a 2-D matrix.
            . obn_matrix_fixed<t, M, N> similar to obn_vector_fixed<t, N> but for a matrix of fixed numbers of rows (M) and columns (N).
        + If FORMAT is OBN_PB_USER then DATATYPE must be a ProtoBuf class generated by protoc. This may not be checked at compile time, but certain necessary methods of a ProtoBuf class for encoding and decoding data must be present. The data assigned to this port will be an object of this ProtoBuf class. The user is responsible for populating the object with appropriate values.
        + If FORMAT is OBN_BIN then DATATYPE is irrelevant because the data written to this output port will be a binary string.
     */
    template <typename F, typename D>
    class YarpOutput;
    
    
    class OBN_PB {};
    class OBN_PB_USER {};
    class OBN_BIN {};
    
    /** Template class to define the ProtoBuf message class for a certain data type */
    template <typename T> struct obn_scalar_PB_message_class;
    template <typename T> struct obn_vector_PB_message_class;
    template <typename T> struct obn_matrix_PB_message_class;

    template <> struct obn_scalar_PB_message_class<bool> { using theclass = OBNSimIOMsg::ScalarBool; };
    template <> struct obn_scalar_PB_message_class<int32_t> { using theclass = OBNSimIOMsg::ScalarInt32; };
    template <> struct obn_scalar_PB_message_class<uint32_t> { using theclass = OBNSimIOMsg::ScalarUInt32; };
    template <> struct obn_scalar_PB_message_class<int64_t> { using theclass = OBNSimIOMsg::ScalarInt64; };
    template <> struct obn_scalar_PB_message_class<uint64_t> { using theclass = OBNSimIOMsg::ScalarUInt64; };
    template <> struct obn_scalar_PB_message_class<float> { using theclass = OBNSimIOMsg::ScalarFloat; };
    template <> struct obn_scalar_PB_message_class<double> { using theclass = OBNSimIOMsg::ScalarDouble; };
    
    template <> struct obn_vector_PB_message_class<bool> { using theclass = OBNSimIOMsg::VectorBool; };
    template <> struct obn_vector_PB_message_class<int32_t> { using theclass = OBNSimIOMsg::VectorInt32; };
    template <> struct obn_vector_PB_message_class<uint32_t> { using theclass = OBNSimIOMsg::VectorUInt32; };
    template <> struct obn_vector_PB_message_class<int64_t> { using theclass = OBNSimIOMsg::VectorInt64; };
    template <> struct obn_vector_PB_message_class<uint64_t> { using theclass = OBNSimIOMsg::VectorUInt64; };
    template <> struct obn_vector_PB_message_class<float> { using theclass = OBNSimIOMsg::VectorFloat; };
    template <> struct obn_vector_PB_message_class<double> { using theclass = OBNSimIOMsg::VectorDouble; };
    
    template <> struct obn_matrix_PB_message_class<bool> { using theclass = OBNSimIOMsg::MatrixBool; };
    template <> struct obn_matrix_PB_message_class<int32_t> { using theclass = OBNSimIOMsg::MatrixInt32; };
    template <> struct obn_matrix_PB_message_class<uint32_t> { using theclass = OBNSimIOMsg::MatrixUInt32; };
    template <> struct obn_matrix_PB_message_class<int64_t> { using theclass = OBNSimIOMsg::MatrixInt64; };
    template <> struct obn_matrix_PB_message_class<uint64_t> { using theclass = OBNSimIOMsg::MatrixUInt64; };
    template <> struct obn_matrix_PB_message_class<float> { using theclass = OBNSimIOMsg::MatrixFloat; };
    template <> struct obn_matrix_PB_message_class<double> { using theclass = OBNSimIOMsg::MatrixDouble; };
    
    
    /** \brief Template class for input data as a scalar of a given type. */
    template <typename T>
    class obn_scalar {
    public:
        /** The input data type, e.g. a vector or a scalar or a matrix. */
        using input_data_type = T;
        
        /** The class type of the ProtoBuf message. */
        using PB_message_class = typename obn_scalar_PB_message_class<T>::theclass;
        
        /** Static function to write data to a ProtoBuf message. */
        static void writePBMessage(const input_data_type& data, PB_message_class& msg) {
            msg.set_value(data);
        }
        
        /** Static function to read data from a ProtoBuf message. */
        static bool readPBMessage(input_data_type& data, const PB_message_class& msg) {
            data = msg.value();
            return true;
        }
    };
    
    
    /** \brief Template class for input data as a vector of a given type. */
    template <typename T>
    class obn_vector {
    public:
        /** The input data type, e.g. a vector or a scalar or a matrix. */
        using input_data_type = Eigen::Matrix<T, Eigen::Dynamic, 1>;
        
        /** The class type of the ProtoBuf message. */
        using PB_message_class = typename obn_vector_PB_message_class<T>::theclass;
        
        /** Static function to write data to a ProtoBuf message.
         It works with raw arrays as much as possible because speed is important.
         */
        static void writePBMessage(const input_data_type& data, PB_message_class& msg) {
            auto sz = data.size();
            auto dest = msg.mutable_value();
            dest->Resize(sz, T());    // resize the field in msg to hold the values
            if (sz > 0) {
                auto itfrom = data.data();
                auto itto = dest->begin();
                for (int i = 0; i < sz; ++i) {
                    *(itto++) = *(itfrom++);
                }
            }
        }
        
        /** Static function to read data from a ProtoBuf message.
         It works with raw arrays as much as possible because speed is important.
         */
        static bool readPBMessage(input_data_type& data, const PB_message_class& msg) {
            auto sz = msg.value_size();
            data.resize(sz, 1);   // resize the vector to match the size of msg
            if (sz != data.size()) return false;
            if (sz > 0) {
                auto itfrom = msg.value().begin();
                auto itto = data.data();
                for (int i = 0; i < sz; ++i) {
                    *(itto++) = *(itfrom++);
                }
            }
            return true;
        }
    };
    
    /** \brief Template class for input data as a dynamic-sized matrix of a given type. */
    template <typename T>
    class obn_matrix {
    public:
        /** The input data type, e.g. a vector or a scalar or a matrix. */
        using input_data_type = Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>;
        
        /** The class type of the ProtoBuf message. */
        using PB_message_class = typename obn_matrix_PB_message_class<T>::theclass;
        
        /** Static function to write data to a ProtoBuf message. */
        static void writePBMessage(const input_data_type& data, PB_message_class& msg) {
            msg.set_nrows(data.rows());
            msg.set_ncols(data.cols());
            auto sz = data.size();
            auto dest = msg.mutable_value();
            dest->Resize(sz, T());    // resize the field in msg to hold the values
            if (sz > 0) {
                auto itfrom = data.data();
                auto itto = dest->begin();
                for (int i = 0; i < sz; ++i) {
                    *(itto++) = *(itfrom++);
                }
            }
        }
        
        /** Static function to read data from a ProtoBuf message. */
        static bool readPBMessage(input_data_type& data, const PB_message_class& msg) {
            auto nrows = msg.nrows();
            auto ncols = msg.ncols();
            auto sz = nrows * ncols;
            if (msg.value_size() < sz) return false;
            
            data.resize(nrows, ncols);   // resize the matrix to match the size of msg
            if (data.rows() != nrows || data.cols() != ncols) return false;
            
            if (sz > 0) {
                auto itfrom = msg.value().begin();
                auto itto = data.data();
                for (int i = 0; i < sz; ++i) {
                    *(itto++) = *(itfrom++);
                }
            }
            return true;
        }
    };
    
    
    /** \brief Template class for input data as a fixed-length vector of a given type. */
    template <typename T, const std::size_t N>
    class obn_vector_fixed {
    public:
        static_assert(N > 0, "Vector length must be positive.");
        
        /** The input data type, e.g. a vector or a scalar or a matrix. */
        using input_data_type = Eigen::Matrix<T, N, 1, Eigen::DontAlign>; // Disable alignment to be safe
        
        /** The class type of the ProtoBuf message. */
        using PB_message_class = typename obn_vector_PB_message_class<T>::theclass;
        
        /** Static function to write data to a ProtoBuf message. */
        static void writePBMessage(const input_data_type& data, PB_message_class& msg) {
            auto dest = msg.mutable_value();
            dest->Resize(N, T());    // resize the field in msg to hold the values
            auto itfrom = data.data();
            auto itto = dest->begin();
            for (int i = 0; i < N; ++i) {
                *(itto++) = *(itfrom++);
            }
        }
        
        /** Static function to read data from a ProtoBuf message. */
        static bool readPBMessage(input_data_type& data, const PB_message_class& msg) {
            if (msg.value_size() < N) return false;
            auto itfrom = msg.value().begin();
            auto itto = data.data();
            for (int i = 0; i < N; ++i) {
                *(itto++) = *(itfrom++);
            }
            return true;
        }
    };

    
    /** \brief Template class for input data as a fixed-size matrix of a given type. */
    template <typename T, const std::size_t NR, const std::size_t NC>
    class obn_matrix_fixed {
    public:
        static_assert((NR > 0) && (NC > 0), "Matrix dimensions must be positive.");
        
        /** The input data type, e.g. a vector or a scalar or a matrix. */
        using input_data_type = Eigen::Matrix<T, NR, NC, Eigen::DontAlign>; // Disable alignment to be safe
        
        /** The class type of the ProtoBuf message. */
        using PB_message_class = typename obn_matrix_PB_message_class<T>::theclass;
        
        /** Static function to write data to a ProtoBuf message. */
        static void writePBMessage(const input_data_type& data, PB_message_class& msg) {
            msg.set_nrows(NR);
            msg.set_ncols(NC);
            auto sz = data.size();
            auto dest = msg.mutable_value();
            dest->Resize(sz, T());    // resize the field in msg to hold the values
            auto itfrom = data.data();
            auto itto = dest->begin();
            for (int i = 0; i < sz; ++i) {
                *(itto++) = *(itfrom++);
            }
        }
        
        /** Static function to read data from a ProtoBuf message. */
        static bool readPBMessage(input_data_type& data, const PB_message_class& msg) {
            if (msg.nrows() != NR || msg.ncols() != NC) return false;
            auto sz = data.size();
            if (msg.value_size() < sz) return false;
            auto itfrom = msg.value().begin();
            auto itto = data.data();
            for (int i = 0; i < sz; ++i) {
                *(itto++) = *(itfrom++);
            }
            return true;
        }
    };
    
    
    /** This templated type is the wrapper class for the data type, e.g. obn_scalar<D> or obn_vector<D>.
     It defines input_data_type, PB_message_class, and read and write functions.
     */
    template <typename D>
    using OBN_DATA_TYPE_CLASS = typename std::conditional<std::is_arithmetic<D>::value, obn_scalar<D>, D>::type;
    
    /** Implementation of YarpInput for fixed data type encoded with ProtoBuf (OBN_PB), non-strict reading. */
    template <typename D>
    class YarpInput<OBN_PB, D, false>: public YarpPortBase,
    protected yarp::os::BufferedPort< YARPMsgPB<OBNSimIOMsg::IOAck, typename OBN_DATA_TYPE_CLASS<D>::PB_message_class> >
    {
        typedef OBN_DATA_TYPE_CLASS<D> _obn_data_type_class;
        typedef YARPMsgPB<OBNSimIOMsg::IOAck, typename OBN_DATA_TYPE_CLASS<D>::PB_message_class> _port_content_type;
        
    public:
        typedef typename _obn_data_type_class::input_data_type ValueType;

    private:
        ValueType _cur_value;    ///< The value stored in this port
        bool _pending_value;    ///< If a new value is pending (hasn't been read)
        typename _obn_data_type_class::PB_message_class _PBMessage;   ///< The ProtoBuf message object to receive the data
        
        mutable yarp::os::Mutex _valueMutex;    ///< Mutex for accessing the value
        
        
        virtual void onRead(_port_content_type& b) {
            // printf("Callback[%s]\n", getName().c_str());
            
            // This managed input port does not generate events in the main thread
            // It simply saves the value in the message to the value
            
            // Parse the ProtoBuf message
            if (!b.getMessage(_PBMessage)) {
                // Error while parsing the raw message
                _theNode->onRawMessageError(this);
                return;
            }
            
            // Read from the ProtoBuf message to the value
            _valueMutex.lock();
            bool result = OBN_DATA_TYPE_CLASS<D>::readPBMessage(_cur_value, _PBMessage);
            if (result) {
                _pending_value = true;
            }
            _valueMutex.unlock();
            
            if (!result) {
                // Error while reading the value, e.g. sizes don't match
                _theNode->onReadValueError(this);
            }
        }
    
    public:
        YarpInput(const std::string& _name): YarpPortBase(_name), _pending_value(false) {
            
        }
        
        /** Get the current value of the port. If no message has been received, the value is undefined.
         The value is copied out, which may be inefficient for large data (e.g. a large vector or matrix).
         */
        ValueType operator() () {
            yarp::os::LockGuard mlock(_valueMutex);
            _pending_value = false; // the value has been read
            return _cur_value;
        }

        /** Get direct read-only access the current value of the port. If no message has been received, the value is undefined.
         A direct reference to the internal value is returned, so there is no copying, which is more efficient for large data.
         If the value is a fixed-size Eigen vector/matrix and is going to be accessed many times, it will be a good idea to copy it to a local variable because the internal value variable in the port is not aligned for vectorization.
            */
        const ValueType& get() {
            yarp::os::LockGuard mlock(_valueMutex);
            _pending_value = false; // the value has been read
            return _cur_value;
        }
        
        /** Return the full port name in the network. */
        virtual std::string fullPortName() const {
            return this->getName();
        }
        
        /** Check if there is a pending input value (that hasn't been read). */
        bool isValuePending() const {
            return _pending_value;
        }
        
        
    protected:
        virtual yarp::os::Contactable& getYarpPort() {
            return *this;
        }
        
        virtual bool configure() {
            // Turn on callback
            this->useCallback();
            return true;
        }
    };

    
    /** Implementation of YarpInput for custom ProtoBuf messages, non-strict reading. */
    template <typename PBCLS>
    class YarpInput<OBN_PB_USER, PBCLS, false>: public YarpPortBase,
    protected yarp::os::BufferedPort< YARPMsgPB<OBNSimIOMsg::IOAck, PBCLS> >
    {
        typedef YARPMsgPB<OBNSimIOMsg::IOAck, PBCLS> _port_content_type;

        PBCLS _cur_message;    ///< The current ProtoBuf data message stored in this port
        bool _pending_value;    ///< If a new value is pending (hasn't been read)
        
        mutable yarp::os::Mutex _valueMutex;    ///< Mutex for accessing the value
        
        virtual void onRead(_port_content_type& b) {
            // printf("Callback[%s]\n", getName().c_str());
            
            // This managed input port does not generate events in the main thread
            // It simply saves the value in the message to the value
            
            // Parse the ProtoBuf message
            _valueMutex.lock();
            bool result = b.getMessage(_cur_message);
            if (result) {
                _pending_value = true;
            }
            _valueMutex.unlock();
            
            if (!result) {
                // Error while parsing the raw message
                _theNode->onRawMessageError(this);
            }
        }
        
    public:
        YarpInput(const std::string& _name): YarpPortBase(_name), _pending_value(false) {
            
        }
        
        /** Get direct read-only access the current message in the port. If no message has been received, the value is undefined.
         A direct reference to the internal value is returned, so there is no copying, which is more efficient for large data.
         */
        const PBCLS& get() {
            yarp::os::LockGuard mlock(_valueMutex);
            _pending_value = false; // the value has been read
            return _cur_message;
        }
        
        /** Return the full port name in the network. */
        virtual std::string fullPortName() const {
            return this->getName();
        }
        
        /** Check if there is a pending input value (that hasn't been read). */
        bool isValuePending() const {
            return _pending_value;
        }
        
        
    protected:
        virtual yarp::os::Contactable& getYarpPort() {
            return *this;
        }
        
        virtual bool configure() {
            // Turn on callback
            this->useCallback();
            return true;
        }
    };
    
    
    /** Implementation of YarpInput for binary data, non-strict reading. */
    template <typename D>
    class YarpInput<OBN_BIN, D, false>: public YarpPortBase,
    protected yarp::os::BufferedPort<YARPMsgBin>
    {
        typedef YARPMsgBin _port_content_type;
        
        std::string _cur_message;    ///< The current binary data message stored in this port
        bool _pending_value;    ///< If a new value is pending (hasn't been read)
        
        mutable yarp::os::Mutex _valueMutex;    ///< Mutex for accessing the value
        
        virtual void onRead(_port_content_type& b) {
            // printf("Callback[%s]\n", getName().c_str());
            
            // This managed input port does not generate events in the main thread
            // It simply saves the value in the message to the value
            
            // Copy the binary data to _cur_message
            _valueMutex.lock();
            _cur_message.assign(b.getBinaryData(), b.getBinaryDataSize());
            _pending_value = true;
            _valueMutex.unlock();
        }
        
    public:
        YarpInput(const std::string& _name): YarpPortBase(_name), _pending_value(false) {
            
        }
        
        /** Get direct read-only access the current binary data in the port, as a std::string. If no message has been received, the value is undefined.
         A direct reference to the internal value is returned, so there is no copying, which is more efficient for large data.
         */
        const std::string& get() {
            yarp::os::LockGuard mlock(_valueMutex);
            _pending_value = false; // the value has been read
            return _cur_message;
        }
        
        /** Return the full port name in the network. */
        virtual std::string fullPortName() const {
            return this->getName();
        }
        
        /** Check if there is a pending input value (that hasn't been read). */
        bool isValuePending() const {
            return _pending_value;
        }
        
        
    protected:
        virtual yarp::os::Contactable& getYarpPort() {
            return *this;
        }
        
        virtual bool configure() {
            // Turn on callback
            this->useCallback();
            return true;
        }
    };
    
//    template <typename D>
//    class YarpInput<OBN_PB, D, true>: public YarpPortBase {
//        // Define the wrapper class for the data type, which defines input_data_type, PB_message_class, and read and write functions.
//        typedef std::conditional<std::is_arithmetic<D>::value, obn_scalar<D>, D> _obn_type_class;
//        
//        /** Because this port is strict, we defines a queue to store the input values. */
//        std::queue<_obn_type_class::input_data_type> _values_queue;
//    };
    
    
    
    /** Implementation of YarpOutput for fixed data type encoded with ProtoBuf (OBN_PB).
     This class of YarpOutput is not thread-safe because usually it's accessed in the main thread only.
     */
    template <typename D>
    class YarpOutput<OBN_PB, D>: public YarpOutputPortBase,
    protected yarp::os::BufferedPort< YARPMsgPB<typename OBN_DATA_TYPE_CLASS<D>::PB_message_class, OBNSimIOMsg::IOAck> >
    {
        typedef OBN_DATA_TYPE_CLASS<D> _obn_data_type_class;
        typedef YARPMsgPB<typename OBN_DATA_TYPE_CLASS<D>::PB_message_class, OBNSimIOMsg::IOAck> _port_content_type;

    public:
        typedef typename _obn_data_type_class::input_data_type ValueType;
        
    private:
        ValueType _cur_value;    ///< The value stored in this port
        typename _obn_data_type_class::PB_message_class _PBMessage;   ///< The ProtoBuf message object to format the data
        
    public:
        
        YarpOutput(const std::string& _name): YarpOutputPortBase(_name) {
        }
        
        /** Get the current (read-only) value of the port.
         The value is copied out, which may be inefficient for large data (e.g. a large vector or matrix).
         */
        ValueType operator() () const {
            return _cur_value;
        }
        
        /** Directly access the value stored in this port; can change it (so it'll be marked as changed).
         If the value is a fixed-size Eigen vector/matrix and is going to be accessed many times, it will be a good idea to copy it to a local variable because the internal value variable in the port is not aligned for vectorization.
         Once all computations are done, the new value can be assigned to the port using either this operator or the assignment operator.
         */
        ValueType& operator* () {
            _isChanged = true;
            return _cur_value;
        }
        
        /** Assign new value to the port. */
        ValueType& operator= (const ValueType && rhs) {
            _cur_value = rhs;
            _isChanged = true;
            return _cur_value;
        }
        
        /** Assign new value to the port. */
        ValueType& operator= (const ValueType & rhs) {
            _cur_value = rhs;
            _isChanged = true;
            return _cur_value;
        }
        
        
        /** Send data synchronously */
        virtual void sendSync() {
            // Convert data to message
            OBN_DATA_TYPE_CLASS<D>::writePBMessage(_cur_value, _PBMessage);
            
            // Prepare the Yarp message to send
            _port_content_type & output = this->prepare();
            if (!output.setMessage(_PBMessage)) {
                // Error while serializing the raw message
                _theNode->onSendMessageError(this);
                return;
            }
            
            // Actually send the message
            this->writeStrict();
            _isChanged = false;
        }
        
        virtual std::string fullPortName() const {
            return this->getName();
        }
        
        
    protected:
        virtual yarp::os::Contactable& getYarpPort() {
            return *this;
        }
        
    };
    
    
    /** Implementation of YarpOutput for custom ProtoBuf data message (OBN_PB_USER).
     This class of YarpOutput is not thread-safe because usually it's accessed in the main thread only.
     */
    template <typename PBCLS>
    class YarpOutput<OBN_PB_USER, PBCLS>: public YarpOutputPortBase,
    protected yarp::os::BufferedPort< YARPMsgPB<PBCLS, OBNSimIOMsg::IOAck> >
    {
        typedef YARPMsgPB<PBCLS, OBNSimIOMsg::IOAck> _port_content_type;
        PBCLS _cur_message;    ///< The ProtoBuf message stored in this port
        
    public:
        YarpOutput(const std::string& _name): YarpOutputPortBase(_name) {
        }
        
        /** Directly access the ProtoBuf message stored in this port; can change it (so it'll be marked as changed). */
        PBCLS& message() {
            _isChanged = true;
            return _cur_message;
        }
        
        /** Send data synchronously */
        virtual void sendSync() {
            // Prepare the Yarp message to send
            _port_content_type & output = this->prepare();
            if (!output.setMessage(_cur_message)) {
                // Error while serializing the raw message
                _theNode->onSendMessageError(this);
                return;
            }
            
            // Actually send the message
            this->writeStrict();
            _isChanged = false;
        }

        
        virtual std::string fullPortName() const {
            return this->getName();
        }
        
        
    protected:
        virtual yarp::os::Contactable& getYarpPort() {
            return *this;
        }
        
    };

    
    /** Implementation of YarpOutput for binary data message (OBN_BIN).
     This class of YarpOutput is not thread-safe because usually it's accessed in the main thread only.
     */
    template <typename D>
    class YarpOutput<OBN_BIN, D>: public YarpOutputPortBase,
    protected yarp::os::BufferedPort< YARPMsgBin >
    {
        typedef YARPMsgBin _port_content_type;
        std::string _cur_message;    ///< The binary data message stored in this port
        
    public:
        YarpOutput(const std::string& _name): YarpOutputPortBase(_name) {
        }
        
        /** Directly access the ProtoBuf message stored in this port; can change it (so it'll be marked as changed). */
        std::string& message() {
            _isChanged = true;
            return _cur_message;
        }
        
        /** Set the binary data content to a std::string */
        std::string& message(const std::string &s) {
            _isChanged = true;
            return _cur_message.assign(s);
        }
        
        /** Set the binary data content to n characters starting from a pointer. */
        std::string& message(const char* s, std::size_t n) {
            _isChanged = true;
            return _cur_message.assign(s, n);
        }
        
        /** Send data synchronously */
        virtual void sendSync() {
            // Prepare the Yarp message to send
            _port_content_type & output = this->prepare();
            output.setBinaryData(_cur_message);
            
            // Actually send the message
            this->writeStrict();
            _isChanged = false;
        }
        
        
        virtual std::string fullPortName() const {
            return this->getName();
        }
        
        
    protected:
        virtual yarp::os::Contactable& getYarpPort() {
            return *this;
        }
        
    };
    
}


#endif /* OBNNODE_YARPPORT_H_ */