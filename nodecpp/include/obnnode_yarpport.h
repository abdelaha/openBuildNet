/* -*- mode: C++; indent-tabs-mode: nil; -*- */
/** \file
 * \brief YARP port classes for the C++ node interface.
 *
 * Implement the communication interface with YARP port for a C++ node.
 *
 * This file is part of the openBuildNet simulation framework
 * (OBN-Sim) developed at EPFL.
 *
 * \author Truong X. Nghiem (xuan.nghiem@epfl.ch)
 */

#ifndef OBNNODE_YARPPORT_H_
#define OBNNODE_YARPPORT_H_

#include <type_traits>
#include <string>
#include <queue>        // std::queue
#include <algorithm>    // std::copy_n, etc.

#include <yarp/os/all.h>
#include <sharedqueue_yarp.h>

#include <Eigen/Core>
#include <obnsim_io.pb.h>

#include <obnnode_yarpportbase.h>
#include <obnnode_yarpnode.h>

#include <obnnode_exceptions.h>

namespace OBNnode {
    
    /** \brief Template class for an Yarp input port with specific type.
     
     This template class defines an Yarp input port with a specific fixed type (e.g. scalar, vector, matrix).
     Specializations are used to define the classes for each type.
     The template has the following signature:
        template <FORMAT, DATATYPE, STRICT> class YarpInput;
     where:
     - FORMAT specifies the message format and is one of: OBN_PB for ProtoBuf for a fixed type, OBN_PB_USER for any ProtoBuf message format (which will be specified by DATATYPE), or OBN_BIN for raw binary data (user-defined format).
     - DATATYPE specifies the type of data, depending on FORMAT
        + If FORMAT is OBN_PB, DATATYPE can be:
            . bool, int32_t, int64_t, uint32_t, uint64_t, double, float: for scalars.
            . obn_vector<t> where t is one of the above types: a variable-length vector of elements of such type.
            . obn_vector_fixed<t, N> where t is one of the above type and N is a constant positive integer: a fixed-length vector of elements of such type. The data is statically allocated, hence more efficient. Incoming data will be checked and an error will be raised if its length is different than N.
            . obn_matrix<t> similar to obn_vector<t> but for a 2-D matrix.
            . obn_matrix_fixed<t, M, N> similar to obn_vector_fixed<t, N> but for a matrix of fixed numbers of rows (M) and columns (N).
        + If FORMAT is OBN_PB_USER then DATATYPE must be a ProtoBuf class generated by protoc. This may not be checked at compile time, but certain necessary methods of a ProtoBuf class for encoding and decoding data must be present. The data read from this port will be an object of this ProtoBuf class. The user is responsible for extracting values from the object.
        + If FORMAT is OBN_BIN then DATATYPE is irrelevant because the data read from this input port will be a binary string.
     - STRICT is a boolean value: if it is false (default), the input port is nonstrict, which means that any new incoming data will immediately replace the current datum (even if it has not been accessed); if it is true, the input port is strict, i.e. new incoming messages will not replace past messages but be queued to be accessed later.
     */
    template <typename F, typename D, const bool S=false>
    class YarpInput;
    
    
    /** \brief Template class for an Yarp output port with specific type.
     
     This template class defines an Yarp output port with a specific fixed type (e.g. scalar, vector, matrix).
     Specializations are used to define the classes for each type.
     The template has the following signature:
     template <FORMAT, DATATYPE> class YarpOutput;
     where:
     - FORMAT specifies the message format and is one of: OBN_PB for ProtoBuf for a fixed type, OBN_PB_USER for any ProtoBuf message format (which will be specified by DATATYPE), or OBN_BIN for raw binary data (user-defined format).
     - DATATYPE specifies the type of data, depending on FORMAT
        + If FORMAT is OBN_PB, DATATYPE can be:
            . bool, int32_t, int64_t, uint32_t, uint64_t, double, float: for scalars.
            . obn_vector<t> where t is one of the above types: a variable-length vector of elements of such type.
            . obn_vector_fixed<t, N> where t is one of the above type and N is a constant positive integer: a fixed-length vector of elements of such type. The data is statically allocated, hence more efficient.
            . obn_matrix<t> similar to obn_vector<t> but for a 2-D matrix.
            . obn_matrix_fixed<t, M, N> similar to obn_vector_fixed<t, N> but for a matrix of fixed numbers of rows (M) and columns (N).
        + If FORMAT is OBN_PB_USER then DATATYPE must be a ProtoBuf class generated by protoc. This may not be checked at compile time, but certain necessary methods of a ProtoBuf class for encoding and decoding data must be present. The data assigned to this port will be an object of this ProtoBuf class. The user is responsible for populating the object with appropriate values.
        + If FORMAT is OBN_BIN then DATATYPE is irrelevant because the data written to this output port will be a binary string.
     */
    template <typename F, typename D>
    class YarpOutput;
    
    
    class OBN_PB {};
    class OBN_PB_USER {};
    class OBN_BIN {};
    
    /** Template class to define the ProtoBuf message class for a certain data type */
    template <typename T> struct obn_scalar_PB_message_class;
    template <typename T> struct obn_vector_PB_message_class;
    template <typename T> struct obn_matrix_PB_message_class;

    template <> struct obn_scalar_PB_message_class<bool> { using theclass = OBNSimIOMsg::ScalarBool; };
    template <> struct obn_scalar_PB_message_class<int32_t> { using theclass = OBNSimIOMsg::ScalarInt32; };
    template <> struct obn_scalar_PB_message_class<uint32_t> { using theclass = OBNSimIOMsg::ScalarUInt32; };
    template <> struct obn_scalar_PB_message_class<int64_t> { using theclass = OBNSimIOMsg::ScalarInt64; };
    template <> struct obn_scalar_PB_message_class<uint64_t> { using theclass = OBNSimIOMsg::ScalarUInt64; };
    template <> struct obn_scalar_PB_message_class<float> { using theclass = OBNSimIOMsg::ScalarFloat; };
    template <> struct obn_scalar_PB_message_class<double> { using theclass = OBNSimIOMsg::ScalarDouble; };
    
    template <> struct obn_vector_PB_message_class<bool> { using theclass = OBNSimIOMsg::VectorBool; };
    template <> struct obn_vector_PB_message_class<int32_t> { using theclass = OBNSimIOMsg::VectorInt32; };
    template <> struct obn_vector_PB_message_class<uint32_t> { using theclass = OBNSimIOMsg::VectorUInt32; };
    template <> struct obn_vector_PB_message_class<int64_t> { using theclass = OBNSimIOMsg::VectorInt64; };
    template <> struct obn_vector_PB_message_class<uint64_t> { using theclass = OBNSimIOMsg::VectorUInt64; };
    template <> struct obn_vector_PB_message_class<float> { using theclass = OBNSimIOMsg::VectorFloat; };
    template <> struct obn_vector_PB_message_class<double> { using theclass = OBNSimIOMsg::VectorDouble; };
    
    template <> struct obn_matrix_PB_message_class<bool> { using theclass = OBNSimIOMsg::MatrixBool; };
    template <> struct obn_matrix_PB_message_class<int32_t> { using theclass = OBNSimIOMsg::MatrixInt32; };
    template <> struct obn_matrix_PB_message_class<uint32_t> { using theclass = OBNSimIOMsg::MatrixUInt32; };
    template <> struct obn_matrix_PB_message_class<int64_t> { using theclass = OBNSimIOMsg::MatrixInt64; };
    template <> struct obn_matrix_PB_message_class<uint64_t> { using theclass = OBNSimIOMsg::MatrixUInt64; };
    template <> struct obn_matrix_PB_message_class<float> { using theclass = OBNSimIOMsg::MatrixFloat; };
    template <> struct obn_matrix_PB_message_class<double> { using theclass = OBNSimIOMsg::MatrixDouble; };
    
    
    /** \brief Template class for input data as a scalar of a given type. */
    template <typename T>
    class obn_scalar {
    public:
        /** The input data type, e.g. a vector or a scalar or a matrix. */
        using input_data_type = T;
        
        /** Initializer for the input type. */
        static const T init_input_data;
        
        /** The output data type, from variable to encoded message. */
        using output_data_type = T;
        
        /** The class type of the ProtoBuf message. */
        using PB_message_class = typename obn_scalar_PB_message_class<T>::theclass;
        
        /** Static function to write data to a ProtoBuf message. */
        static void writePBMessage(const output_data_type& data, PB_message_class& msg) {
            msg.set_value(data);
        }
        
        /** Static function to read data from a ProtoBuf message. */
        static bool readPBMessage(input_data_type& data, const PB_message_class& msg) {
            data = msg.value();
            return true;
        }
    };
    template<typename T> const T obn_scalar<T>::init_input_data(0); // = static_cast<T>(0);
    
    
    /** \brief Template class for input data as a vector of a given type, using Eigen library. */
    template <typename T>
    class obn_vector {
    public:
        /** The input data type for reading from an encoded format (e.g. ProtoBuf) into the given type.
         We use Eigen::Map to avoid copying data, i.e. we directly access the internal data of the encoded message,
         therefore the message must be permanent (it can't be a temporary variable that will be destroyed) and
         anytime the message changes, the vector variable must be updated. */
        using input_data_type = Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, 1> >; // const because this is read-only
        
        /** Initializer for the input type. */
        static const input_data_type init_input_data;
        
        /** The output data type for writing from the given type to an encoded format (e.g. ProtoBuf).
         We use an Eigen variable as a buffer, and will only write it to the message on demand. */
        using output_data_type = Eigen::Matrix<T, Eigen::Dynamic, 1>;
        
        /** The class type of the ProtoBuf message. */
        using PB_message_class = typename obn_vector_PB_message_class<T>::theclass;
        
        /** Static function to write data to a ProtoBuf message.
         It works with raw arrays as much as possible because speed is important.
         */
        static void writePBMessage(const output_data_type& data, PB_message_class& msg) {
            auto sz = data.size();
            auto dest = msg.mutable_value();
            dest->Resize(sz, T());    // resize the field in msg to hold the values
            std::copy_n(data.data(), sz, dest->begin());
        }
        
        /** Static function to read data from a ProtoBuf message.
         It works with raw arrays as much as possible because speed is important.
         */
        static bool readPBMessage(input_data_type& data, const PB_message_class& msg) {
            auto sz = msg.value_size();
            new (&data) input_data_type(msg.value().data(), sz);
            
//            data.resize(sz, 1);   // resize the vector to match the size of msg
//            if (sz != data.size()) return false;
//            if (sz > 0) {
//                auto itfrom = msg.value().begin();
//                auto itto = data.data();
//                for (int i = 0; i < sz; ++i) {
//                    *(itto++) = *(itfrom++);
//                }
//            }
            return true;
        }
    };
    template<typename T> const typename obn_vector<T>::input_data_type obn_vector<T>::init_input_data(nullptr, 0);
    
    /** \brief Template class for input data as a dynamic-sized matrix of a given type. */
    template <typename T>
    class obn_matrix {
    public:
        /** The input data type for reading from an encoded format (e.g. ProtoBuf) into the given type.
         We use Eigen::Map to avoid copying data, i.e. we directly access the internal data of the encoded message,
         therefore the message must be permanent (it can't be a temporary variable that will be destroyed) and
         anytime the message changes, the matrix variable must be updated. */
        using input_data_type = Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> >;  // const because this is read-only
        
        /** Initializer for the input type. */
        static const input_data_type init_input_data;
        
        /** The output data type for writing from the given type to an encoded format (e.g. ProtoBuf).
         We use an Eigen variable as a buffer, and will only write it to the message on demand. */
        using output_data_type = Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>;
        
        /** The class type of the ProtoBuf message. */
        using PB_message_class = typename obn_matrix_PB_message_class<T>::theclass;
        
        /** Static function to write data to a ProtoBuf message. */
        static void writePBMessage(const output_data_type& data, PB_message_class& msg) {
            msg.set_nrows(data.rows());
            msg.set_ncols(data.cols());
            auto sz = data.size();
            auto dest = msg.mutable_value();
            dest->Resize(sz, T());    // resize the field in msg to hold the values
            std::copy_n(data.data(), sz, dest->begin());
        }
        
        /** Static function to read data from a ProtoBuf message. */
        static bool readPBMessage(input_data_type& data, const PB_message_class& msg) {
            auto nrows = msg.nrows();
            auto ncols = msg.ncols();
            auto sz = nrows * ncols;
            if (msg.value_size() < sz) return false;
            
            new (&data) input_data_type(msg.value().data(), nrows, ncols);
            
//            data.resize(nrows, ncols);   // resize the matrix to match the size of msg
//            if (data.rows() != nrows || data.cols() != ncols) return false;
//            
//            if (sz > 0) {
//                auto itfrom = msg.value().begin();
//                auto itto = data.data();
//                for (int i = 0; i < sz; ++i) {
//                    *(itto++) = *(itfrom++);
//                }
//            }
            return true;
        }
    };
    template<typename T> const typename obn_matrix<T>::input_data_type obn_matrix<T>::init_input_data(nullptr, 0, 0);
    
    
    /** \brief Template class for input data as a fixed-length vector of a given type. */
    template <typename T, const std::size_t N>
    class obn_vector_fixed {
    public:
        static_assert(N > 0, "Vector length must be positive.");
        
        /** The input data type: a vector. For fixed size types, to be safe, we use an actual vector, not a Map. This is because the user can access the input port when it hasn't been initialized (by an input message), potentially crashing the program. */
        using input_data_type = Eigen::Matrix<T, N, 1, Eigen::DontAlign>; // Disable alignment to be safe
        
        /** Initializer for the input type. */
        static const std::size_t init_input_data;
        
        /** The output data type for writing from the given type to an encoded format (e.g. ProtoBuf).
         We use an Eigen variable as a buffer, and will only write it to the message on demand. */
        using output_data_type = Eigen::Matrix<T, N, 1, Eigen::DontAlign>;
        
        /** The class type of the ProtoBuf message. */
        using PB_message_class = typename obn_vector_PB_message_class<T>::theclass;
        
        /** Static function to write data to a ProtoBuf message. */
        static void writePBMessage(const output_data_type& data, PB_message_class& msg) {
            auto dest = msg.mutable_value();
            dest->Resize(N, T());    // resize the field in msg to hold the values
            std::copy_n(data.data(), N, dest->begin());
        }
        
        /** Static function to read data from a ProtoBuf message. */
        static bool readPBMessage(input_data_type& data, const PB_message_class& msg) {
            if (msg.value_size() < N) return false;
            std::copy_n(msg.value().begin(), N, data.data());
            return true;
        }
    };
    template<typename T, const std::size_t N> const std::size_t obn_vector_fixed<T, N>::init_input_data = N;

    
    /** \brief Template class for input data as a fixed-size matrix of a given type. */
    template <typename T, const std::size_t NR, const std::size_t NC>
    class obn_matrix_fixed {
    public:
        static_assert((NR > 0) && (NC > 0), "Matrix dimensions must be positive.");
        
        /** The input data type: a matrix. For fixed size types, to be safe, we use an actual matrix, not a Map. This is because the user can access the input port when it hasn't been initialized (by an input message), potentially crashing the program. */
        using input_data_type = Eigen::Matrix<T, NR, NC, Eigen::DontAlign>; // Disable alignment to be safe

        /** Initializer for the input type. */
        static const input_data_type init_input_data;
        
        /** The output data type for writing from the given type to an encoded format (e.g. ProtoBuf).
         We use an Eigen variable as a buffer, and will only write it to the message on demand. */
        using output_data_type = Eigen::Matrix<T, NR, NC, Eigen::DontAlign>;
        
        /** The class type of the ProtoBuf message. */
        using PB_message_class = typename obn_matrix_PB_message_class<T>::theclass;
        
        /** Static function to write data to a ProtoBuf message. */
        static void writePBMessage(const output_data_type& data, PB_message_class& msg) {
            msg.set_nrows(NR);
            msg.set_ncols(NC);
            auto sz = data.size();
            auto dest = msg.mutable_value();
            dest->Resize(sz, T());    // resize the field in msg to hold the values
            std::copy_n(data.data(), sz, dest->begin());
        }
        
        /** Static function to read data from a ProtoBuf message. */
        static bool readPBMessage(input_data_type& data, const PB_message_class& msg) {
            if (msg.nrows() != NR || msg.ncols() != NC) return false;
            auto sz = data.size();
            if (msg.value_size() < sz) return false;
            std::copy_n(msg.value().begin(), sz, data.data());
            return true;
        }
    };
    template<typename T, const std::size_t NR, const std::size_t NC> const typename obn_matrix_fixed<T,NR,NC>::input_data_type obn_matrix_fixed<T,NR,NC>::init_input_data(NR, NC);
    
    
    /** This templated type is the wrapper class for the data type, e.g. obn_scalar<D> or obn_vector<D>.
     It defines input_data_type, PB_message_class, and read and write functions.
     */
    template <typename D>
    using OBN_DATA_TYPE_CLASS = typename std::conditional<std::is_arithmetic<D>::value, obn_scalar<D>, D>::type;
    
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //          Implementations of YarpInput for non-strict reading ports
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    
    /** Implementation of YarpInput for fixed data type encoded with ProtoBuf (OBN_PB), non-strict reading. */
    template <typename D>
    class YarpInput<OBN_PB, D, false>: public YarpPortBase,
    protected yarp::os::BufferedPort< YARPMsgPB<OBNSimIOMsg::IOAck, typename OBN_DATA_TYPE_CLASS<D>::PB_message_class> >
    {
        typedef OBN_DATA_TYPE_CLASS<D> _obn_data_type_class;
        typedef YARPMsgPB<OBNSimIOMsg::IOAck, typename OBN_DATA_TYPE_CLASS<D>::PB_message_class> _port_content_type;
        
    public:
        typedef typename _obn_data_type_class::input_data_type ValueType;

    private:
        ValueType _cur_value;    ///< The typed value stored in this port
        bool _pending_value;    ///< If a new value is pending (hasn't been read)
        
        /** The ProtoBuf message object to receive the data.
         This should be a permanent variable (a class member) rather than a temporary variable (in a function)
         because some implementations directly use the data stored in this message, rather than copying the data over.
         If a temporary message variable is used, in those cases, the program may crash (invalid access error). */
        typename _obn_data_type_class::PB_message_class _PBMessage;
        
        mutable yarp::os::Mutex _valueMutex;    ///< Mutex for accessing the value
        
        virtual void onRead(_port_content_type& b) {
            // printf("Callback[%s]\n", getName().c_str());
            
            // This managed input port does not generate events in the main thread
            // It simply saves the value in the message to the value
            
            try {
                // Parse the ProtoBuf message
                if (!b.getMessage(_PBMessage)) {
                    // Error while parsing the raw message
                    throw OBNnode::inputport_error(this, OBNnode::inputport_error::ERR_RAWMSG);
                }
                
                // Read from the ProtoBuf message to the value
                _valueMutex.lock();
                bool result = OBN_DATA_TYPE_CLASS<D>::readPBMessage(_cur_value, _PBMessage);
                if (result) {
                    _pending_value = true;
                }
                _valueMutex.unlock();
                
                if (!result) {
                    // Error while reading the value, e.g. sizes don't match
                    throw OBNnode::inputport_error(this, OBNnode::inputport_error::ERR_READVALUE);
                }
                
            } catch (...) {
                // Catch everything and pass it to the main thread
                _theNode->postExceptionEvent(std::current_exception());
            }
        }
    
    public:
        YarpInput(const std::string& _name): YarpPortBase(_name), _cur_value(_obn_data_type_class::init_input_data), _pending_value(false) {
            
        }
        
        /** Get the current value of the port. If no message has been received, the value is undefined.
         The value is copied out, which may be inefficient for large data (e.g. a large vector or matrix).
         */
        ValueType operator() () {
            yarp::os::LockGuard mlock(_valueMutex);
            _pending_value = false; // the value has been read
            return _cur_value;
        }

        /** Get direct read-only access the current value of the port. If no message has been received, the value is undefined.
         A direct reference to the internal value is returned, so there is no copying, which is more efficient for large data.
         If the value is a fixed-size Eigen vector/matrix and is going to be accessed many times, it will be a good idea to copy it to a local variable because the internal value variable in the port is not aligned for vectorization.
            */
        const ValueType& get() {
            yarp::os::LockGuard mlock(_valueMutex);
            _pending_value = false; // the value has been read
            return _cur_value;
        }
        
        /** Return the full port name in the network. */
        virtual std::string fullPortName() const {
            return this->getName();
        }
        
        /** Check if there is a pending input value (that hasn't been read). */
        bool isValuePending() const {
            return _pending_value;
        }
        
        
    protected:
        virtual yarp::os::Contactable& getYarpPort() {
            return *this;
        }
        
        virtual bool configure() {
            // Turn on callback
            this->useCallback();
            return true;
        }
    };

    
    /** Implementation of YarpInput for custom ProtoBuf messages, non-strict reading. */
    template <typename PBCLS>
    class YarpInput<OBN_PB_USER, PBCLS, false>: public YarpPortBase,
    protected yarp::os::BufferedPort< YARPMsgPB<OBNSimIOMsg::IOAck, PBCLS> >
    {
        typedef YARPMsgPB<OBNSimIOMsg::IOAck, PBCLS> _port_content_type;

        PBCLS _cur_message;    ///< The current ProtoBuf data message stored in this port
        bool _pending_value;    ///< If a new value is pending (hasn't been read)
        
        mutable yarp::os::Mutex _valueMutex;    ///< Mutex for accessing the value
        
        virtual void onRead(_port_content_type& b) {
            // printf("Callback[%s]\n", getName().c_str());
            
            // This managed input port does not generate events in the main thread
            // It simply saves the value in the message to the value
            
            try {
                // Parse the ProtoBuf message
                _valueMutex.lock();
                bool result = b.getMessage(_cur_message);
                if (result) {
                    _pending_value = true;
                }
                _valueMutex.unlock();
                
                if (!result) {
                    // Error while parsing the raw message
                    throw OBNnode::inputport_error(this, OBNnode::inputport_error::ERR_RAWMSG);
                }
            } catch (...) {
                // Catch everything and pass it to the main thread
                _theNode->postExceptionEvent(std::current_exception());
            }
        }
        
    public:
        YarpInput(const std::string& _name): YarpPortBase(_name), _pending_value(false) {
            
        }
        
        /** Get direct read-only access the current message in the port. If no message has been received, the value is undefined.
         A direct reference to the internal value is returned, so there is no copying, which is more efficient for large data.
         */
        const PBCLS& get() {
            yarp::os::LockGuard mlock(_valueMutex);
            _pending_value = false; // the value has been read
            return _cur_message;
        }
        
        /** Return the full port name in the network. */
        virtual std::string fullPortName() const {
            return this->getName();
        }
        
        /** Check if there is a pending input value (that hasn't been read). */
        bool isValuePending() const {
            return _pending_value;
        }
        
        
    protected:
        virtual yarp::os::Contactable& getYarpPort() {
            return *this;
        }
        
        virtual bool configure() {
            // Turn on callback
            this->useCallback();
            return true;
        }
    };
    
    
    /** Implementation of YarpInput for binary data, non-strict reading. */
    template <typename D>
    class YarpInput<OBN_BIN, D, false>: public YarpPortBase,
    protected yarp::os::BufferedPort<YARPMsgBin>
    {
        typedef YARPMsgBin _port_content_type;
        
        std::string _cur_message;    ///< The current binary data message stored in this port
        bool _pending_value;    ///< If a new value is pending (hasn't been read)
        
        mutable yarp::os::Mutex _valueMutex;    ///< Mutex for accessing the value
        
        virtual void onRead(_port_content_type& b) {
            // printf("Callback[%s]\n", getName().c_str());
            
            // This managed input port does not generate events in the main thread
            // It simply saves the value in the message to the value
            
            // Copy the binary data to _cur_message
            _valueMutex.lock();
            _cur_message.assign(b.getBinaryData(), b.getBinaryDataSize());
            _pending_value = true;
            _valueMutex.unlock();
        }
        
    public:
        YarpInput(const std::string& _name): YarpPortBase(_name), _pending_value(false) {
            
        }
        
        /** Get direct read-only access the current binary data in the port, as a std::string. If no message has been received, the value is undefined.
         A direct reference to the internal value is returned, so there is no copying, which is more efficient for large data.
         */
        const std::string& get() {
            yarp::os::LockGuard mlock(_valueMutex);
            _pending_value = false; // the value has been read
            return _cur_message;
        }
        
        /** Return the full port name in the network. */
        virtual std::string fullPortName() const {
            return this->getName();
        }
        
        /** Check if there is a pending input value (that hasn't been read). */
        bool isValuePending() const {
            return _pending_value;
        }
        
        
    protected:
        virtual yarp::os::Contactable& getYarpPort() {
            return *this;
        }
        
        virtual bool configure() {
            // Turn on callback
            this->useCallback();
            return true;
        }
    };
    
    
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //          Implementations of YarpInput for strict reading ports
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    
    /** Implementation of YarpInput for fixed data type encoded with ProtoBuf (OBN_PB), non-strict reading. */
    template <typename D>
    class YarpInput<OBN_PB, D, true>: public YarpPortBase,
    protected yarp::os::BufferedPort< YARPMsgPB<OBNSimIOMsg::IOAck, typename OBN_DATA_TYPE_CLASS<D>::PB_message_class> >
    {
        typedef OBN_DATA_TYPE_CLASS<D> _obn_data_type_class;
        typedef YARPMsgPB<OBNSimIOMsg::IOAck, typename OBN_DATA_TYPE_CLASS<D>::PB_message_class> _port_content_type;
        
    public:
        typedef typename _obn_data_type_class::input_data_type ValueType;
        
    private:
        
        typedef std::deque<ValueType> ValueQueueType;
        ValueQueueType m_value_queue;    ///< The queue of values stored in this port
        ValueType m_temp_value;         ///< Temporary value object to read from the port before being pushed to the queue
        typename _obn_data_type_class::PB_message_class _PBMessage;   ///< The ProtoBuf message object to receive the data
        mutable yarp::os::Mutex _valueMutex;    ///< Mutex for accessing the value queue
        
        bool m_generate_events = false;     ///< Whether this port should generate an event everytime it receives new data

        YarpNode::EventCallbackFunction m_callback;     ///< The callback function
        
        
        virtual void onRead(_port_content_type& b) {
            // printf("Callback[%s]\n", getName().c_str());
            
            // This input port may optionally generate events in the main thread to call a given callback function.
            // The received data are always saved in the queue.
            
            // Parse the ProtoBuf message
            if (!b.getMessage(_PBMessage)) {
                // Error while parsing the raw message
                _theNode->onRawMessageError(this);
                return;
            }
            
            // Read from the ProtoBuf message to the value
            _valueMutex.lock();
            bool result = OBN_DATA_TYPE_CLASS<D>::readPBMessage(m_temp_value, _PBMessage);
            if (result) {
                m_value_queue.push(m_temp_value);
            }
            _valueMutex.unlock();
            
            // Optionally add a new event to the main thread
            if (m_generate_events && result) {
                _theNode->postEvent(m_callback);
            }
            
            if (!result) {
                // Error while reading the value, e.g. sizes don't match
                _theNode->onReadValueError(this);
            }
        }
        
    public:
        YarpInput(const std::string& _name): YarpPortBase(_name) { }

        /** Construct a port object that will generate an event in the main thread for each new datum it receives, with a given callback function. */
        YarpInput(const std::string& _name, const YarpNode::EventCallbackFunction &t_callback): YarpInput(_name) {
            if (t_callback) {
                // Only if t_callback is callable (i.e. a valid callback function)
                m_generate_events = true;
                m_callback = t_callback;
            }
        }
        
        
        /** Get the size of the value queue of the port. */
        ValueQueueType::size_type size() const {
            yarp::os::LockGuard mlock(_valueMutex);
            return m_value_queue.size();
        }
        
        /** Check if the value queue of the port is empty. */
        bool empty() const {
            yarp::os::LockGuard mlock(_valueMutex);
            return m_value_queue.empty();
        }
        
        /** Return a reference to the next value in the queue (the oldest one).
         If the queue is empty, an exception is usually thrown; use empty() to check the emptiness of the queue.
         No thread safety is used, but it should be fine because the queue is strictly managed by this object.
         */
        ValueQueueType::reference& next() {
            return _valueMutex
        }
        
        
        ValueType operator() () {
            yarp::os::LockGuard mlock(_valueMutex);
            _pending_value = false; // the value has been read
            return _cur_value;
        }
        
        /** Get direct read-only access the current value of the port. If no message has been received, the value is undefined.
         A direct reference to the internal value is returned, so there is no copying, which is more efficient for large data.
         If the value is a fixed-size Eigen vector/matrix and is going to be accessed many times, it will be a good idea to copy it to a local variable because the internal value variable in the port is not aligned for vectorization.
         */
        const ValueType& get() {
            yarp::os::LockGuard mlock(_valueMutex);
            _pending_value = false; // the value has been read
            return _cur_value;
        }
        
        /** Return the full port name in the network. */
        virtual std::string fullPortName() const {
            return this->getName();
        }
        
        /** Check if there is a pending input value (that hasn't been read). */
        bool isValuePending() const {
            return _pending_value;
        }
        
        
    protected:
        virtual yarp::os::Contactable& getYarpPort() {
            return *this;
        }
        
        virtual bool configure() {
            // Turn on callback
            this->useCallback();
            return true;
        }
    };
    
    
    /** Implementation of YarpInput for custom ProtoBuf messages, non-strict reading. */
    template <typename PBCLS>
    class YarpInput<OBN_PB_USER, PBCLS, false>: public YarpPortBase,
    protected yarp::os::BufferedPort< YARPMsgPB<OBNSimIOMsg::IOAck, PBCLS> >
    {
        typedef YARPMsgPB<OBNSimIOMsg::IOAck, PBCLS> _port_content_type;
        
        PBCLS _cur_message;    ///< The current ProtoBuf data message stored in this port
        bool _pending_value;    ///< If a new value is pending (hasn't been read)
        
        mutable yarp::os::Mutex _valueMutex;    ///< Mutex for accessing the value
        
        virtual void onRead(_port_content_type& b) {
            // printf("Callback[%s]\n", getName().c_str());
            
            // This managed input port does not generate events in the main thread
            // It simply saves the value in the message to the value
            
            // Parse the ProtoBuf message
            _valueMutex.lock();
            bool result = b.getMessage(_cur_message);
            if (result) {
                _pending_value = true;
            }
            _valueMutex.unlock();
            
            if (!result) {
                // Error while parsing the raw message
                _theNode->onRawMessageError(this);
            }
        }
        
    public:
        YarpInput(const std::string& _name): YarpPortBase(_name), _pending_value(false) {
            
        }
        
        /** Get direct read-only access the current message in the port. If no message has been received, the value is undefined.
         A direct reference to the internal value is returned, so there is no copying, which is more efficient for large data.
         */
        const PBCLS& get() {
            yarp::os::LockGuard mlock(_valueMutex);
            _pending_value = false; // the value has been read
            return _cur_message;
        }
        
        /** Return the full port name in the network. */
        virtual std::string fullPortName() const {
            return this->getName();
        }
        
        /** Check if there is a pending input value (that hasn't been read). */
        bool isValuePending() const {
            return _pending_value;
        }
        
        
    protected:
        virtual yarp::os::Contactable& getYarpPort() {
            return *this;
        }
        
        virtual bool configure() {
            // Turn on callback
            this->useCallback();
            return true;
        }
    };
    
    
    /** Implementation of YarpInput for binary data, non-strict reading. */
    template <typename D>
    class YarpInput<OBN_BIN, D, false>: public YarpPortBase,
    protected yarp::os::BufferedPort<YARPMsgBin>
    {
        typedef YARPMsgBin _port_content_type;
        
        std::string _cur_message;    ///< The current binary data message stored in this port
        bool _pending_value;    ///< If a new value is pending (hasn't been read)
        
        mutable yarp::os::Mutex _valueMutex;    ///< Mutex for accessing the value
        
        virtual void onRead(_port_content_type& b) {
            // printf("Callback[%s]\n", getName().c_str());
            
            // This managed input port does not generate events in the main thread
            // It simply saves the value in the message to the value
            
            // Copy the binary data to _cur_message
            _valueMutex.lock();
            _cur_message.assign(b.getBinaryData(), b.getBinaryDataSize());
            _pending_value = true;
            _valueMutex.unlock();
        }
        
    public:
        YarpInput(const std::string& _name): YarpPortBase(_name), _pending_value(false) {
            
        }
        
        /** Get direct read-only access the current binary data in the port, as a std::string. If no message has been received, the value is undefined.
         A direct reference to the internal value is returned, so there is no copying, which is more efficient for large data.
         */
        const std::string& get() {
            yarp::os::LockGuard mlock(_valueMutex);
            _pending_value = false; // the value has been read
            return _cur_message;
        }
        
        /** Return the full port name in the network. */
        virtual std::string fullPortName() const {
            return this->getName();
        }
        
        /** Check if there is a pending input value (that hasn't been read). */
        bool isValuePending() const {
            return _pending_value;
        }
        
        
    protected:
        virtual yarp::os::Contactable& getYarpPort() {
            return *this;
        }
        
        virtual bool configure() {
            // Turn on callback
            this->useCallback();
            return true;
        }
    };
    
//    template <typename D>
//    class YarpInput<OBN_PB, D, true>: public YarpPortBase {
//        // Define the wrapper class for the data type, which defines input_data_type, PB_message_class, and read and write functions.
//        typedef std::conditional<std::is_arithmetic<D>::value, obn_scalar<D>, D> _obn_type_class;
//        
//        /** Because this port is strict, we defines a queue to store the input values. */
//        std::queue<_obn_type_class::input_data_type> _values_queue;
//    };
    
    
    
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //          Implementations of YarpOutput
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    
    /** Implementation of YarpOutput for fixed data type encoded with ProtoBuf (OBN_PB).
     This class of YarpOutput is not thread-safe because usually it's accessed in the main thread only.
     */
    template <typename D>
    class YarpOutput<OBN_PB, D>: public YarpOutputPortBase,
    protected yarp::os::BufferedPort< YARPMsgPB<typename OBN_DATA_TYPE_CLASS<D>::PB_message_class, OBNSimIOMsg::IOAck> >
    {
        typedef OBN_DATA_TYPE_CLASS<D> _obn_data_type_class;
        typedef YARPMsgPB<typename OBN_DATA_TYPE_CLASS<D>::PB_message_class, OBNSimIOMsg::IOAck> _port_content_type;

    public:
        typedef typename _obn_data_type_class::output_data_type ValueType;
        
    private:
        ValueType _cur_value;    ///< The value stored in this port
        typename _obn_data_type_class::PB_message_class _PBMessage;   ///< The ProtoBuf message object to format the data
        
    public:
        
        YarpOutput(const std::string& _name): YarpOutputPortBase(_name) {
        }
        
        /** Get the current (read-only) value of the port.
         The value is copied out, which may be inefficient for large data (e.g. a large vector or matrix).
         */
        ValueType operator() () const {
            return _cur_value;
        }
        
        /** Directly access the value stored in this port; can change it (so it'll be marked as changed).
         If the value is a fixed-size Eigen vector/matrix and is going to be accessed many times, it will be a good idea to copy it to a local variable because the internal value variable in the port is not aligned for vectorization.
         Once all computations are done, the new value can be assigned to the port using either this operator or the assignment operator.
         */
        ValueType& operator* () {
            _isChanged = true;
            return _cur_value;
        }
        
        /** Assign new value to the port. */
        ValueType& operator= (const ValueType && rhs) {
            _cur_value = rhs;
            _isChanged = true;
            return _cur_value;
        }
        
        /** Assign new value to the port. */
        ValueType& operator= (const ValueType & rhs) {
            _cur_value = rhs;
            _isChanged = true;
            return _cur_value;
        }
        
        
        /** Send data synchronously */
        virtual void sendSync() {
            try {
                // Convert data to message
                OBN_DATA_TYPE_CLASS<D>::writePBMessage(_cur_value, _PBMessage);
                
                // Prepare the Yarp message to send
                _port_content_type & output = this->prepare();
                if (!output.setMessage(_PBMessage)) {
                    // Error while serializing the raw message
                    throw OBNnode::outputport_error(this, OBNnode::outputport_error::ERR_SENDMSG);
                }
                
                // Actually send the message
                this->writeStrict();
                _isChanged = false;
            }
            catch (...) {
                // Catch everything and pass it to the main thread
                _theNode->postExceptionEvent(std::current_exception());
            }
        }
    
        virtual std::string fullPortName() const {
            return this->getName();
        }
        
        
    protected:
        virtual yarp::os::Contactable& getYarpPort() {
            return *this;
        }
        
    };
    
    
    /** Implementation of YarpOutput for custom ProtoBuf data message (OBN_PB_USER).
     This class of YarpOutput is not thread-safe because usually it's accessed in the main thread only.
     */
    template <typename PBCLS>
    class YarpOutput<OBN_PB_USER, PBCLS>: public YarpOutputPortBase,
    protected yarp::os::BufferedPort< YARPMsgPB<PBCLS, OBNSimIOMsg::IOAck> >
    {
        typedef YARPMsgPB<PBCLS, OBNSimIOMsg::IOAck> _port_content_type;
        PBCLS _cur_message;    ///< The ProtoBuf message stored in this port
        
    public:
        YarpOutput(const std::string& _name): YarpOutputPortBase(_name) {
        }
        
        /** Directly access the ProtoBuf message stored in this port; can change it (so it'll be marked as changed). */
        PBCLS& message() {
            _isChanged = true;
            return _cur_message;
        }
        
        /** Send data synchronously */
        virtual void sendSync() {
            try {
                // Prepare the Yarp message to send
                _port_content_type & output = this->prepare();
                if (!output.setMessage(_cur_message)) {
                    // Error while serializing the raw message
                    throw OBNnode::outputport_error(this, OBNnode::outputport_error::ERR_SENDMSG);
                }
                
                // Actually send the message
                this->writeStrict();
                _isChanged = false;
            }
            catch (...) {
                _theNode->postExceptionEvent(std::current_exception());
            }
        }

        
        virtual std::string fullPortName() const {
            return this->getName();
        }
        
        
    protected:
        virtual yarp::os::Contactable& getYarpPort() {
            return *this;
        }
        
    };

    
    /** Implementation of YarpOutput for binary data message (OBN_BIN).
     This class of YarpOutput is not thread-safe because usually it's accessed in the main thread only.
     */
    template <typename D>
    class YarpOutput<OBN_BIN, D>: public YarpOutputPortBase,
    protected yarp::os::BufferedPort< YARPMsgBin >
    {
        typedef YARPMsgBin _port_content_type;
        std::string _cur_message;    ///< The binary data message stored in this port
        
    public:
        YarpOutput(const std::string& _name): YarpOutputPortBase(_name) {
        }
        
        /** Directly access the ProtoBuf message stored in this port; can change it (so it'll be marked as changed). */
        std::string& message() {
            _isChanged = true;
            return _cur_message;
        }
        
        /** Set the binary data content to a std::string */
        std::string& message(const std::string &s) {
            _isChanged = true;
            return _cur_message.assign(s);
        }
        
        /** Set the binary data content to n characters starting from a pointer. */
        std::string& message(const char* s, std::size_t n) {
            _isChanged = true;
            return _cur_message.assign(s, n);
        }
        
        /** Send data synchronously */
        virtual void sendSync() {
            // Prepare the Yarp message to send
            _port_content_type & output = this->prepare();
            output.setBinaryData(_cur_message);
            
            // Actually send the message
            this->writeStrict();
            _isChanged = false;
        }
        
        
        virtual std::string fullPortName() const {
            return this->getName();
        }
        
        
    protected:
        virtual yarp::os::Contactable& getYarpPort() {
            return *this;
        }
        
    };
    
}


#endif /* OBNNODE_YARPPORT_H_ */